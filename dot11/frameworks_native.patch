From 3a74ba5355de1c3038ec2dc05b8283133ccff811 Mon Sep 17 00:00:00 2001
From: Albert I <kras@raphielgang.org>
Date: Sun, 28 Mar 2021 15:35:49 +0800
Subject: [PATCH 1/5] Revert "InputDispatcher: On keypress, deliver keycode to
 pokeUserActivity"

This reverts commit 50d2a912fe5a79e359522c5f7bf3f86e933a27ea.

Signed-off-by: Albert I <kras@raphielgang.org>
Change-Id: I0f94b534ed24003651a778dcb98e4586719248c8
---
 .../dispatcher/InputDispatcher.cpp            | 46 ++++++-------------
 .../inputflinger/dispatcher/InputDispatcher.h |  2 +-
 .../include/InputDispatcherPolicyInterface.h  |  2 +-
 3 files changed, 16 insertions(+), 34 deletions(-)

diff --git a/services/inputflinger/dispatcher/InputDispatcher.cpp b/services/inputflinger/dispatcher/InputDispatcher.cpp
index 4e0edd838..fd910b46b 100644
--- a/services/inputflinger/dispatcher/InputDispatcher.cpp
+++ b/services/inputflinger/dispatcher/InputDispatcher.cpp
@@ -619,7 +619,7 @@ void InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) {
 
         // Poke user activity for this event.
         if (mPendingEvent->policyFlags & POLICY_FLAG_PASS_TO_USER) {
-            pokeUserActivityLocked(mPendingEvent);
+            pokeUserActivityLocked(*mPendingEvent);
         }
     }
 
@@ -1379,7 +1379,7 @@ void InputDispatcher::dispatchEventLocked(nsecs_t currentTime, EventEntry* event
 
     ALOG_ASSERT(eventEntry->dispatchInProgress); // should already have been set to true
 
-    pokeUserActivityLocked(eventEntry);
+    pokeUserActivityLocked(*eventEntry);
 
     for (const InputTarget& inputTarget : inputTargets) {
         sp<Connection> connection =
@@ -2187,12 +2187,12 @@ std::string InputDispatcher::getApplicationWindowLabel(
     }
 }
 
-void InputDispatcher::pokeUserActivityLocked(const EventEntry* eventEntry) {
-    if (eventEntry->type == EventEntry::Type::FOCUS) {
+void InputDispatcher::pokeUserActivityLocked(const EventEntry& eventEntry) {
+    if (eventEntry.type == EventEntry::Type::FOCUS) {
         // Focus events are passed to apps, but do not represent user activity.
         return;
     }
-    int32_t displayId = getTargetDisplayId(*eventEntry);
+    int32_t displayId = getTargetDisplayId(eventEntry);
     sp<InputWindowHandle> focusedWindowHandle =
             getValueByKey(mFocusedWindowHandlesByDisplay, displayId);
     if (focusedWindowHandle != nullptr) {
@@ -2206,21 +2206,21 @@ void InputDispatcher::pokeUserActivityLocked(const EventEntry* eventEntry) {
     }
 
     int32_t eventType = USER_ACTIVITY_EVENT_OTHER;
-    switch (eventEntry->type) {
+    switch (eventEntry.type) {
         case EventEntry::Type::MOTION: {
-            const MotionEntry* motionEntry = static_cast<const MotionEntry*>(eventEntry);
-            if (motionEntry->action == AMOTION_EVENT_ACTION_CANCEL) {
+            const MotionEntry& motionEntry = static_cast<const MotionEntry&>(eventEntry);
+            if (motionEntry.action == AMOTION_EVENT_ACTION_CANCEL) {
                 return;
             }
 
-            if (MotionEvent::isTouchEvent(motionEntry->source, motionEntry->action)) {
+            if (MotionEvent::isTouchEvent(motionEntry.source, motionEntry.action)) {
                 eventType = USER_ACTIVITY_EVENT_TOUCH;
             }
             break;
         }
         case EventEntry::Type::KEY: {
-            const KeyEntry* keyEntry = static_cast<const KeyEntry*>(eventEntry);
-            if (keyEntry->flags & AKEY_EVENT_FLAG_CANCELED) {
+            const KeyEntry& keyEntry = static_cast<const KeyEntry&>(eventEntry);
+            if (keyEntry.flags & AKEY_EVENT_FLAG_CANCELED) {
                 return;
             }
             eventType = USER_ACTIVITY_EVENT_BUTTON;
@@ -2230,20 +2230,15 @@ void InputDispatcher::pokeUserActivityLocked(const EventEntry* eventEntry) {
         case EventEntry::Type::CONFIGURATION_CHANGED:
         case EventEntry::Type::DEVICE_RESET: {
             LOG_ALWAYS_FATAL("%s events are not user activity",
-                             EventEntry::typeToString(eventEntry->type));
+                             EventEntry::typeToString(eventEntry.type));
             break;
         }
     }
 
     std::unique_ptr<CommandEntry> commandEntry =
             std::make_unique<CommandEntry>(&InputDispatcher::doPokeUserActivityLockedInterruptible);
-    commandEntry->eventTime = eventEntry->eventTime;
+    commandEntry->eventTime = eventEntry.eventTime;
     commandEntry->userActivityEventType = eventType;
-    if (eventType == USER_ACTIVITY_EVENT_BUTTON) {
-        const KeyEntry* keyEntry = static_cast<const KeyEntry*>(eventEntry);
-        commandEntry->keyEntry = const_cast<KeyEntry*>(keyEntry);
-        keyEntry->refCount += 1;
-    }
     postCommandLocked(std::move(commandEntry));
 }
 
@@ -5037,20 +5032,7 @@ bool InputDispatcher::afterMotionEventLockedInterruptible(const sp<Connection>&
 void InputDispatcher::doPokeUserActivityLockedInterruptible(CommandEntry* commandEntry) {
     mLock.unlock();
 
-    int32_t keyCode = AKEYCODE_UNKNOWN;
-
-    if (commandEntry->userActivityEventType == USER_ACTIVITY_EVENT_BUTTON &&
-            commandEntry->keyEntry) {
-        keyCode = commandEntry->keyEntry->keyCode;
-    }
-
-    mPolicy->pokeUserActivity(commandEntry->eventTime, commandEntry->userActivityEventType,
-            keyCode);
-
-    if (commandEntry->userActivityEventType == USER_ACTIVITY_EVENT_BUTTON &&
-            commandEntry->keyEntry) {
-        commandEntry->keyEntry->release();
-    }
+    mPolicy->pokeUserActivity(commandEntry->eventTime, commandEntry->userActivityEventType);
 
     mLock.lock();
 }
diff --git a/services/inputflinger/dispatcher/InputDispatcher.h b/services/inputflinger/dispatcher/InputDispatcher.h
index 452ef6b99..23d7e01d1 100644
--- a/services/inputflinger/dispatcher/InputDispatcher.h
+++ b/services/inputflinger/dispatcher/InputDispatcher.h
@@ -417,7 +417,7 @@ private:
     void addGlobalMonitoringTargetsLocked(std::vector<InputTarget>& inputTargets, int32_t displayId,
                                           float xOffset = 0, float yOffset = 0) REQUIRES(mLock);
 
-    void pokeUserActivityLocked(const EventEntry* eventEntry) REQUIRES(mLock);
+    void pokeUserActivityLocked(const EventEntry& eventEntry) REQUIRES(mLock);
     bool checkInjectionPermission(const sp<InputWindowHandle>& windowHandle,
                                   const InjectionState* injectionState);
     bool isWindowObscuredAtPointLocked(const sp<InputWindowHandle>& windowHandle, int32_t x,
diff --git a/services/inputflinger/dispatcher/include/InputDispatcherPolicyInterface.h b/services/inputflinger/dispatcher/include/InputDispatcherPolicyInterface.h
index 4cb083d4f..667af9bbd 100644
--- a/services/inputflinger/dispatcher/include/InputDispatcherPolicyInterface.h
+++ b/services/inputflinger/dispatcher/include/InputDispatcherPolicyInterface.h
@@ -99,7 +99,7 @@ public:
                               uint32_t policyFlags) = 0;
 
     /* Poke user activity for an event dispatched to a window. */
-    virtual void pokeUserActivity(nsecs_t eventTime, int32_t eventType, int32_t keyCode) = 0;
+    virtual void pokeUserActivity(nsecs_t eventTime, int32_t eventType) = 0;
 
     /* Checks whether a given application pid/uid has permission to inject input events
      * into other applications.
-- 
2.31.0


From d4f15701e2c6f951549becf924792917306f592d Mon Sep 17 00:00:00 2001
From: Adithya R <gh0strider.2k18.reborn@gmail.com>
Date: Mon, 18 Jan 2021 20:40:52 +0530
Subject: [PATCH 2/5] InputDispatcher: extend "do not freeze recent on event
 from FOD" to side FP

fixes this issue on devices like surya

Signed-off-by: Albert I <kras@raphielgang.org>
---
 services/inputflinger/dispatcher/InputDispatcher.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/services/inputflinger/dispatcher/InputDispatcher.cpp b/services/inputflinger/dispatcher/InputDispatcher.cpp
index fd910b46b..b025989d3 100644
--- a/services/inputflinger/dispatcher/InputDispatcher.cpp
+++ b/services/inputflinger/dispatcher/InputDispatcher.cpp
@@ -1189,8 +1189,8 @@ bool InputDispatcher::dispatchKeyLocked(nsecs_t currentTime, KeyEntry* entry,
     // Give the policy a chance to intercept the key.
     if (entry->interceptKeyResult == KeyEntry::INTERCEPT_KEY_RESULT_UNKNOWN) {
         if (entry->policyFlags & POLICY_FLAG_PASS_TO_USER) {
-            // Key from FOD
-            if(entry->keyCode == 0 && entry->scanCode == 338){
+            // Key from fingerprint sensor
+            if(entry->keyCode == 0 && (entry->scanCode == 338 || entry->scanCode == 96)){
                 entry->interceptKeyResult = KeyEntry::INTERCEPT_KEY_RESULT_SKIP;
                 *dropReason = DropReason::POLICY;
                 ALOGI("Key from FOD");
-- 
2.31.0


From ec41140fd5c6e20f787bf952439def18599c1af9 Mon Sep 17 00:00:00 2001
From: Sandepp Sethi <adeveloper79@gmail.com>
Date: Tue, 2 Mar 2021 08:20:02 +0000
Subject: [PATCH 3/5] InputDispatcher: extend "do not freeze recent on event
 from FOD and side FP" to xiaomi-touch event

fixes ANR/Scrolling issues on devices like apollo/pro

Signed-off-by: Sandepp Sethi <adeveloper79@gmail.com>
Signed-off-by: Albert I <kras@raphielgang.org>
---
 services/inputflinger/dispatcher/InputDispatcher.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/services/inputflinger/dispatcher/InputDispatcher.cpp b/services/inputflinger/dispatcher/InputDispatcher.cpp
index b025989d3..fc575cdce 100644
--- a/services/inputflinger/dispatcher/InputDispatcher.cpp
+++ b/services/inputflinger/dispatcher/InputDispatcher.cpp
@@ -1189,8 +1189,8 @@ bool InputDispatcher::dispatchKeyLocked(nsecs_t currentTime, KeyEntry* entry,
     // Give the policy a chance to intercept the key.
     if (entry->interceptKeyResult == KeyEntry::INTERCEPT_KEY_RESULT_UNKNOWN) {
         if (entry->policyFlags & POLICY_FLAG_PASS_TO_USER) {
-            // Key from fingerprint sensor
-            if(entry->keyCode == 0 && (entry->scanCode == 338 || entry->scanCode == 96)){
+            // Key from fingerprint sensor/xiaomi-touch
+            if(entry->keyCode == 0 && (entry->scanCode == 338 || entry->scanCode == 96 || entry->scanCode == 339)){
                 entry->interceptKeyResult = KeyEntry::INTERCEPT_KEY_RESULT_SKIP;
                 *dropReason = DropReason::POLICY;
                 ALOGI("Key from FOD");
-- 
2.31.0


From e26b72ce8d6ae7bd00db1420a1d39c64c530d06e Mon Sep 17 00:00:00 2001
From: Yiwei Zhang <zzyiwei@google.com>
Date: Fri, 14 Aug 2020 11:55:18 -0700
Subject: [PATCH 4/5] OpenGL: fix initializeAnglePlatform with built-in ANGLE
 driver

When ANGLE namespace doesn't exist and initializeAnglePlatform is
called, ANGLE driver is loaded as built-in gl driver in sphal namespace.
This change fixes the fallback path here.

Bug: 154237217
Test: atest CtsAngleIntegrationHostTestCases
Change-Id: I0e4ecf65fac0d91b5542d475439e1e6f9541b629
Merged-In: I0e4ecf65fac0d91b5542d475439e1e6f9541b629
Signed-off-by: Akash Srivastava <akashniki@gmail.com>
Signed-off-by: Albert I <kras@raphielgang.org>
---
 opengl/libs/EGL/egl_angle_platform.cpp | 25 ++++++++++++++++++++-----
 1 file changed, 20 insertions(+), 5 deletions(-)

diff --git a/opengl/libs/EGL/egl_angle_platform.cpp b/opengl/libs/EGL/egl_angle_platform.cpp
index 97dc0f137..f82c2a4ee 100644
--- a/opengl/libs/EGL/egl_angle_platform.cpp
+++ b/opengl/libs/EGL/egl_angle_platform.cpp
@@ -29,9 +29,13 @@
 #include <graphicsenv/GraphicsEnv.h>
 #include <time.h>
 #include <log/log.h>
+#include <vndksupport/linker.h>
 
 namespace angle {
 
+constexpr char kAngleEs2Lib[] = "libGLESv2_angle.so";
+constexpr int kAngleDlFlags = RTLD_LOCAL | RTLD_NOW;
+
 static GetDisplayPlatformFunc angleGetDisplayPlatform = nullptr;
 static ResetDisplayPlatformFunc angleResetDisplayPlatform = nullptr;
 
@@ -101,11 +105,22 @@ static void assignAnglePlatformMethods(PlatformMethods* platformMethods) {
 bool initializeAnglePlatform(EGLDisplay dpy) {
     // Since we're inside libEGL, use dlsym to lookup fptr for ANGLEGetDisplayPlatform
     android_namespace_t* ns = android::GraphicsEnv::getInstance().getAngleNamespace();
-    const android_dlextinfo dlextinfo = {
-            .flags = ANDROID_DLEXT_USE_NAMESPACE,
-            .library_namespace = ns,
-    };
-    void* so = android_dlopen_ext("libGLESv2_angle.so", RTLD_LOCAL | RTLD_NOW, &dlextinfo);
+    void* so = nullptr;
+    if (ns) {
+        const android_dlextinfo dlextinfo = {
+                .flags = ANDROID_DLEXT_USE_NAMESPACE,
+                .library_namespace = ns,
+        };
+        so = android_dlopen_ext(kAngleEs2Lib, kAngleDlFlags, &dlextinfo);
+    } else {
+        // If we are here, ANGLE is loaded as built-in gl driver in the sphal.
+        so = android_load_sphal_library(kAngleEs2Lib, kAngleDlFlags);
+    }
+    if (!so) {
+        ALOGE("%s failed to dlopen %s!", __FUNCTION__, kAngleEs2Lib);
+        return false;
+    }
+
     angleGetDisplayPlatform =
             reinterpret_cast<GetDisplayPlatformFunc>(dlsym(so, "ANGLEGetDisplayPlatform"));
 
-- 
2.31.0


From 8431a3780c241a2b1176988501205faa398d93d6 Mon Sep 17 00:00:00 2001
From: Tim Van Patten <timvp@google.com>
Date: Tue, 2 Mar 2021 19:24:29 -0700
Subject: [PATCH 5/5] Read ro.hardware.egl for ANGLE's filename

The ANGLE shared object filename is currently hardcoded to
libGLESv2_angle.so, which prevents OEMs from specifying their own
filename when using ANGLE as the default OpenGL ES driver.

This CL updates initializeAnglePlatform() to build the ANGLE library
filename using the suffix specified by ro.hardware.egl when loading
ANGLE as the default OpenGL ES driver.

The filename when loading ANGLE from an APK will remain
libGLESv2_angle.so, for compatibilty reasons. This enforces naming
conventions when loading ANGLE APKs on to the device, regardless of the
name of the built-in version of ANGLE.

Bug: 178871212
Test: Build and launch CF
Merged-In: I462e076fc500d84fa2a27abfa491f82db4a9df80
Change-Id: I59805445fd101707bda867d29c23a25e24f173d8
Signed-off-by: Akash Srivatava <akashniki@gmail.com>
Signed-off-by: Albert I <kras@raphielgang.org>
---
 opengl/libs/EGL/egl_angle_platform.cpp | 32 ++++++++++++++++++++------
 1 file changed, 25 insertions(+), 7 deletions(-)

diff --git a/opengl/libs/EGL/egl_angle_platform.cpp b/opengl/libs/EGL/egl_angle_platform.cpp
index f82c2a4ee..d98c1ba1f 100644
--- a/opengl/libs/EGL/egl_angle_platform.cpp
+++ b/opengl/libs/EGL/egl_angle_platform.cpp
@@ -24,16 +24,16 @@
 #include <EGL/Platform.h>
 #pragma GCC diagnostic pop
 
+#include <android-base/properties.h>
 #include <android/dlext.h>
 #include <dlfcn.h>
 #include <graphicsenv/GraphicsEnv.h>
-#include <time.h>
 #include <log/log.h>
+#include <time.h>
 #include <vndksupport/linker.h>
 
 namespace angle {
 
-constexpr char kAngleEs2Lib[] = "libGLESv2_angle.so";
 constexpr int kAngleDlFlags = RTLD_LOCAL | RTLD_NOW;
 
 static GetDisplayPlatformFunc angleGetDisplayPlatform = nullptr;
@@ -107,18 +107,36 @@ bool initializeAnglePlatform(EGLDisplay dpy) {
     android_namespace_t* ns = android::GraphicsEnv::getInstance().getAngleNamespace();
     void* so = nullptr;
     if (ns) {
+        // Loading from an APK, so hard-code the suffix to "_angle".
+        constexpr char kAngleEs2Lib[] = "libGLESv2_angle.so";
         const android_dlextinfo dlextinfo = {
                 .flags = ANDROID_DLEXT_USE_NAMESPACE,
                 .library_namespace = ns,
         };
         so = android_dlopen_ext(kAngleEs2Lib, kAngleDlFlags, &dlextinfo);
+        if (so) {
+            ALOGD("dlopen_ext from APK (%s) success at %p", kAngleEs2Lib, so);
+        } else {
+            ALOGE("dlopen_ext(\"%s\") failed: %s", kAngleEs2Lib, dlerror());
+            return false;
+        }
     } else {
         // If we are here, ANGLE is loaded as built-in gl driver in the sphal.
-        so = android_load_sphal_library(kAngleEs2Lib, kAngleDlFlags);
-    }
-    if (!so) {
-        ALOGE("%s failed to dlopen %s!", __FUNCTION__, kAngleEs2Lib);
-        return false;
+        // Get the specified ANGLE library filename suffix.
+        std::string angleEs2LibSuffix = android::base::GetProperty("ro.hardware.egl", "");
+        if (angleEs2LibSuffix.empty()) {
+            ALOGE("%s failed to get valid ANGLE library filename suffix!", __FUNCTION__);
+            return false;
+        }
+
+        std::string angleEs2LibName = "libGLESv2_" + angleEs2LibSuffix + ".so";
+        so = android_load_sphal_library(angleEs2LibName.c_str(), kAngleDlFlags);
+        if (so) {
+            ALOGD("dlopen (%s) success at %p", angleEs2LibName.c_str(), so);
+        } else {
+            ALOGE("%s failed to dlopen %s!", __FUNCTION__, angleEs2LibName.c_str());
+            return false;
+        }
     }
 
     angleGetDisplayPlatform =
-- 
2.31.0

